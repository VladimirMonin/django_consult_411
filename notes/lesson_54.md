# Lesson 54


## Миграции Django
Традиционно, при первом запуске Django проекта, нас встречает сообщение о наличии 18 служебных непримененных миграций. Это нормальное явление, так как Django поставляется с набором встроенных приложений (например, для аутентификации, администрирования), которые требуют создания своих таблиц в базе данных.

### Что такое миграции?
Миграции в Django — это способ отслеживания изменений в вашей модели данных (то есть в файлах `models.py`) и их применения к базе данных. Вместо того чтобы писать SQL-запросы вручную для создания или изменения таблиц, вы описываете свои модели на Python, а Django генерирует необходимые SQL-команды. Это позволяет вам легко изменять структуру базы данных по мере развития вашего проекта, сохраняя при этом целостность данных. Каждая миграция представляет собой файл Python, который описывает набор изменений, таких как создание таблиц, добавление полей, изменение типов данных и т.д.

### Команды `makemigrations` и `migrate`
Для работы с миграциями используются две основные команды:

*   `poetry run python manage.py makemigrations`: Эта команда сканирует ваши файлы `models.py` на предмет изменений. Если Django обнаруживает, что вы добавили, изменили или удалили модели или поля, он создает новый файл миграции в соответствующей папке `migrations` вашего приложения. Этот файл содержит инструкции для преобразования текущей схемы базы данных в новую.
*   `poetry run python manage.py migrate`: Эта команда применяет непримененные миграции к вашей базе данных. Она читает файлы миграций и выполняет соответствующие SQL-операции, чтобы обновить схему базы данных. Django отслеживает, какие миграции уже были применены, чтобы избежать повторного выполнения.

### Что происходит в Базе данных?
Когда вы применяете миграции, Django создает или изменяет таблицы в вашей базе данных в соответствии с определениями ваших моделей. Например, если вы создаете модель `Master`, Django создаст таблицу `core_master` (где `core` — это название вашего приложения, а `master` — название модели) со столбцами, соответствующими полям вашей модели. Django также создает служебную таблицу `django_migrations`, в которой хранится информация о всех примененных миграциях, что позволяет ему отслеживать состояние схемы базы данных.



## Первая модель Django ORM
Для начала работы с базой данных в Django мы определяем модели. Модель — это класс Python, который наследуется от `django.db.models.Model` и описывает структуру таблицы в базе данных. Каждое поле в классе модели соответствует столбцу в таблице базы данных.

Рассмотрим пример создания первой модели `Master` в файле `core/models.py`:

```python
from django.db import models

class Master(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    middle_name = models.CharField(max_length=100)
```
Здесь мы определили модель `Master` с тремя полями: `first_name`, `last_name` и `middle_name`. Все они являются полями типа `CharField`, что соответствует строковым полям в базе данных. Важно отметить, что для `CharField` необходимо указывать `max_length`.

### Применение миграций
После определения модели необходимо создать и применить миграции, чтобы Django мог создать соответствующую таблицу в базе данных.

1.  **Создание миграции**:
    Мы создаем файл миграции, который описывает изменения в нашей модели, с помощью команды:
    `poetry run python manage.py makemigrations`
    Эта команда сгенерирует новый файл в директории `core/migrations/`, например, `0001_initial.py`, который будет содержать инструкции для создания таблицы `core_master`.

2.  **Применение миграции**:
    Затем мы применяем эту миграцию к базе данных, выполнив команду:
    `poetry run python manage.py migrate`
    Эта команда выполнит SQL-операции, описанные в файле миграции, и создаст таблицу `core_master` в вашей базе данных.

После успешного применения миграций, если мы посмотрим в базу данных (например, используя `db.sqlite3` и соответствующий инструмент для просмотра SQLite баз данных), мы увидим новую таблицу `core_master`. Название таблицы формируется из названия приложения (`core`) и названия модели (`master`), разделенных нижним подчеркиванием.

На следующем изображении показан пример того, как выглядит таблица `core_master` в базе данных после применения миграций. Мы видим столбцы `id`, `first_name`, `last_name`, `middle_name`, которые соответствуют полям нашей модели `Master`.

![первая модель](./images/first_model.png)

Это изображение демонстрирует структуру таблицы `core_master` в базе данных, подтверждая, что миграция успешно создала необходимые столбцы.

В контексте коммитов, этот этап соответствует коммиту с сообщением: `lesson_54: первая модель`.

Далее, если мы попытаемся добавить новое поле, например `phone`, без указания значения по умолчанию, Django выдаст ошибку:

```
It is impossible to add a non-nullable field 'phone' to master without specifying a default. This is because the database needs something to populate existing rows.
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit and manually define a default value in models.py.
Select an option:
```
Это сообщение означает, что Django не может добавить новое поле `phone`, которое по умолчанию является `NOT NULL` (то есть не может быть пустым), к уже существующей таблице `master`, так как в ней уже могут быть записи, для которых это поле будет пустым. Django предлагает два варианта решения: либо предоставить одноразовое значение по умолчанию для существующих записей, либо вручную определить значение по умолчанию в `models.py`.


## Изменение модели
В процессе разработки часто возникает необходимость изменить существующие модели, например, добавить новые поля. Предположим, мы осознали, что забыли добавить поле `phone` в нашу модель `Master`. Мы можем обновить `core/models.py` следующим образом:

```python
from django.db import models

class Master(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    middle_name = models.CharField(max_length=100)
    phone = models.CharField(max_length=20) # Добавлено новое поле
```
Однако, при попытке создать новую миграцию командой `poetry run python manage.py makemigrations`, Django выдаст следующее сообщение об ошибке:

```
It is impossible to add a non-nullable field 'phone' to master without specifying a default. This is because the database needs something to populate existing rows.
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit and manually define a default value in models.py.
Select an option:
```
Эта ошибка возникает потому, что по умолчанию `CharField` является `NOT NULL` (не может быть пустым). Если в таблице `core_master` уже есть записи, Django не знает, какое значение присвоить новому полю `phone` для этих существующих записей. Это важный механизм Django, который предотвращает потерю данных и обеспечивает их целостность.

Мы можем выбрать второй вариант, предложенный Django, и вручную модифицировать модель, чтобы разрешить полю `phone` быть пустым или иметь значение по умолчанию. Для этого мы добавляем параметры `null=True` и `default=None` к определению поля:

```python
from django.db import models

class Master(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    middle_name = models.CharField(max_length=100)
    phone = models.CharField(max_length=20, null=True, default=None) # Поле теперь может быть пустым
```
*   `null=True`: Позволяет полю быть `NULL` в базе данных.
*   `default=None`: Устанавливает значение `None` (что в базе данных соответствует `NULL`) для новых записей, если значение не указано.

Таким образом, Django миграции заботятся о том, чтобы не потерять данные при изменении схемы базы данных. Они требуют явного указания, как обрабатывать новые поля для существующих записей, если эти поля не могут быть пустыми.

После внесения этих изменений в `models.py`, мы снова создаем миграцию:
`poetry run python manage.py makemigrations`
Django сгенерирует новый файл миграции (например, `0002_master_phone.py`), который будет содержать инструкции по добавлению поля `phone` в таблицу `core_master`, разрешая `NULL` значения.

Затем применяем эту миграцию:
`poetry run python manage.py migrate`
Теперь таблица `core_master` будет обновлена, и в ней появится новое поле `phone`, которое может содержать `NULL` значения.

## Откатить миграции
Иногда возникает необходимость откатить примененные миграции, например, для отмены изменений в схеме базы данных или для возврата к предыдущему состоянию. Django предоставляет возможность отката миграций для конкретного приложения или для всех приложений.

Для отката миграций используется команда `poetry run python manage.py migrate <app_label> <migration_name>`.
*   `<app_label>`: Название приложения, миграции которого вы хотите откатить (например, `core`).
*   `<migration_name>`: Имя миграции, до которой вы хотите откатиться. Это может быть полный номер миграции (например, `0001`) или `zero` для полного отката всех миграций приложения.

Примеры:

*   **Откат до определенной миграции**:
    `poetry run python manage.py migrate core 0001`
    Эта команда откатит все миграции приложения `core` до миграции с номером `0001`. Если у вас были миграции `0002_master_phone.py`, `0003_another_change.py` и т.д., они будут отменены, и схема базы данных вернется к состоянию после применения миграции `0001_initial.py`.

*   **Полный откат всех миграций приложения**:
    `poetry run python manage.py migrate core zero`
    Эта команда полностью откатит все миграции для приложения `core`, удалив все таблицы, связанные с этим приложением, из базы данных. Это полезно, когда вы хотите начать с чистого листа для определенного приложения.

При откате миграций Django выполняет обратные SQL-операции, которые были применены при создании миграций. Например, если миграция создавала таблицу, откат этой миграции удалит таблицу. Если миграция добавляла столбец, откат удалит этот столбец.

## Создание суперпользователя
После настройки моделей и применения миграций, часто требуется создать учетную запись суперпользователя для доступа к административной панели Django. Суперпользователь имеет полные права на управление всеми данными в приложении через встроенный административный интерфейс.

Для создания суперпользователя используется команда:
`poetry run python manage.py createsuperuser`

При выполнении этой команды вам будет предложено ввести имя пользователя, адрес электронной почты (необязательно) и пароль для новой учетной записи суперпользователя. После успешного создания вы сможете войти в административную панель Django (обычно доступную по адресу `/admin/` после запуска сервера разработки) и начать управлять данными ваших моделей.

## Свойства полей

### Большая сводная таблица типов полей
В таблице должны быть следующие поля:
- Название свойства
- Описание свойства
- Параметры которые туда можно вписать (max_length, null, blank и т.д.)



- `CharField` - строка фиксированной длины
- `EmailField` - строка для email


### Большая сводная таблица характеристик полей

- Название свойства
- Описание свойства
- В каких типах полей используется и для чего

### `null = True` и `blank = True`

Если мы не указываем `null=True` для поля, то Django по умолчанию устанавливает `null=False`. Это делает поле обязательным для заполнения при создании объекта модели.

Что такое `blank=True` и чем отличается от `null=True`?

### Можно ли поставить default=None но не ставить null=True?
...

## Завершили модель `Master`

class Master(models.Model):
    first_name = models.CharField(max_length=100, verbose_name="Имя")
    last_name = models.CharField(max_length=100, verbose_name="Фамилия")
    middle_name = models.CharField(
        null=True, blank=True, max_length=100, verbose_name="Отчество"
    )
    phone = models.CharField(max_length=20, verbose_name="Телефон", default="00000000000")
    email = models.EmailField(null=True, blank=True, verbose_name="Email")

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

    class Meta:
        # на русском языке - в ед. числе и мн. числе
        verbose_name = "Мастер"
        verbose_name_plural = "Мастера"
        # сортировка по фамилии и имени
        ordering = ["last_name", "first_name"]


## Подключим модель `Master` к админке