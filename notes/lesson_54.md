# Lesson 54

## Миграции Django

Традиционно, при первом запуске Django проекта, нас встречает сообщение о наличии 18 служебных непримененных миграций. Это нормальное явление, так как Django поставляется с набором встроенных приложений (например, для аутентификации, администрирования), которые требуют создания своих таблиц в базе данных.

### Что такое миграции?

Миграции в Django — это способ отслеживания изменений в вашей модели данных (то есть в файлах `models.py`) и их применения к базе данных. Вместо того чтобы писать SQL-запросы вручную для создания или изменения таблиц, вы описываете свои модели на Python, а Django генерирует необходимые SQL-команды. Это позволяет вам легко изменять структуру базы данных по мере развития вашего проекта, сохраняя при этом целостность данных. Каждая миграция представляет собой файл Python, который описывает набор изменений, таких как создание таблиц, добавление полей, изменение типов данных и т.д.

### Команды `makemigrations` и `migrate`

Для работы с миграциями используются две основные команды:

* `poetry run python manage.py makemigrations`: Эта команда сканирует ваши файлы `models.py` на предмет изменений. Если Django обнаруживает, что вы добавили, изменили или удалили модели или поля, он создает новый файл миграции в соответствующей папке `migrations` вашего приложения. Этот файл содержит инструкции для преобразования текущей схемы базы данных в новую.
* `poetry run python manage.py migrate`: Эта команда применяет непримененные миграции к вашей базе данных. Она читает файлы миграций и выполняет соответствующие SQL-операции, чтобы обновить схему базы данных. Django отслеживает, какие миграции уже были применены, чтобы избежать повторного выполнения.

### Что происходит в Базе данных?

Когда вы применяете миграции, Django создает или изменяет таблицы в вашей базе данных в соответствии с определениями ваших моделей. Например, если вы создаете модель `Master`, Django создаст таблицу `core_master` (где `core` — это название вашего приложения, а `master` — название модели) со столбцами, соответствующими полям вашей модели. Django также создает служебную таблицу `django_migrations`, в которой хранится информация о всех примененных миграциях, что позволяет ему отслеживать состояние схемы базы данных.

## Первая модель Django ORM

Для начала работы с базой данных в Django мы определяем модели. Модель — это класс Python, который наследуется от `django.db.models.Model` и описывает структуру таблицы в базе данных. Каждое поле в классе модели соответствует столбцу в таблице базы данных.

Рассмотрим пример создания первой модели `Master` в файле `core/models.py`:

```python
from django.db import models

class Master(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    middle_name = models.CharField(max_length=100)
```

Здесь мы определили модель `Master` с тремя полями: `first_name`, `last_name` и `middle_name`. Все они являются полями типа `CharField`, что соответствует строковым полям в базе данных. Важно отметить, что для `CharField` необходимо указывать `max_length`.

### Применение миграций

После определения модели необходимо создать и применить миграции, чтобы Django мог создать соответствующую таблицу в базе данных.

1. **Создание миграции**:
    Мы создаем файл миграции, который описывает изменения в нашей модели, с помощью команды:
    `poetry run python manage.py makemigrations`
    Эта команда сгенерирует новый файл в директории `core/migrations/`, например, `0001_initial.py`, который будет содержать инструкции для создания таблицы `core_master`.

2. **Применение миграции**:
    Затем мы применяем эту миграцию к базе данных, выполнив команду:
    `poetry run python manage.py migrate`
    Эта команда выполнит SQL-операции, описанные в файле миграции, и создаст таблицу `core_master` в вашей базе данных.

После успешного применения миграций, если мы посмотрим в базу данных (например, используя `db.sqlite3` и соответствующий инструмент для просмотра SQLite баз данных), мы увидим новую таблицу `core_master`. Название таблицы формируется из названия приложения (`core`) и названия модели (`master`), разделенных нижним подчеркиванием.

На следующем изображении показан пример того, как выглядит таблица `core_master` в базе данных после применения миграций. Мы видим столбцы `id`, `first_name`, `last_name`, `middle_name`, которые соответствуют полям нашей модели `Master`.

![первая модель](./images/first_model.png)

Это изображение демонстрирует структуру таблицы `core_master` в базе данных, подтверждая, что миграция успешно создала необходимые столбцы.

В контексте коммитов, этот этап соответствует коммиту с сообщением: `lesson_54: первая модель`.

Далее, если мы попытаемся добавить новое поле, например `phone`, без указания значения по умолчанию, Django выдаст ошибку:

```
It is impossible to add a non-nullable field 'phone' to master without specifying a default. This is because the database needs something to populate existing rows.
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit and manually define a default value in models.py.
Select an option:
```

Это сообщение означает, что Django не может добавить новое поле `phone`, которое по умолчанию является `NOT NULL` (то есть не может быть пустым), к уже существующей таблице `master`, так как в ней уже могут быть записи, для которых это поле будет пустым. Django предлагает два варианта решения: либо предоставить одноразовое значение по умолчанию для существующих записей, либо вручную определить значение по умолчанию в `models.py`.

## Изменение модели

В процессе разработки часто возникает необходимость изменить существующие модели, например, добавить новые поля. Предположим, мы осознали, что забыли добавить поле `phone` в нашу модель `Master`. Мы можем обновить `core/models.py` следующим образом:

```python
from django.db import models

class Master(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    middle_name = models.CharField(max_length=100)
    phone = models.CharField(max_length=20) # Добавлено новое поле
```

Однако, при попытке создать новую миграцию командой `poetry run python manage.py makemigrations`, Django выдаст следующее сообщение об ошибке:

```
It is impossible to add a non-nullable field 'phone' to master without specifying a default. This is because the database needs something to populate existing rows.
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit and manually define a default value in models.py.
Select an option:
```

Эта ошибка возникает потому, что по умолчанию `CharField` является `NOT NULL` (не может быть пустым). Если в таблице `core_master` уже есть записи, Django не знает, какое значение присвоить новому полю `phone` для этих существующих записей. Это важный механизм Django, который предотвращает потерю данных и обеспечивает их целостность.

Мы можем выбрать второй вариант, предложенный Django, и вручную модифицировать модель, чтобы разрешить полю `phone` быть пустым или иметь значение по умолчанию. Для этого мы добавляем параметры `null=True` и `default=None` к определению поля:

```python
from django.db import models

class Master(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    middle_name = models.CharField(max_length=100)
    phone = models.CharField(max_length=20, null=True, default=None) # Поле теперь может быть пустым
```

* `null=True`: Позволяет полю быть `NULL` в базе данных.
* `default=None`: Устанавливает значение `None` (что в базе данных соответствует `NULL`) для новых записей, если значение не указано.

Таким образом, Django миграции заботятся о том, чтобы не потерять данные при изменении схемы базы данных. Они требуют явного указания, как обрабатывать новые поля для существующих записей, если эти поля не могут быть пустыми.

После внесения этих изменений в `models.py`, мы снова создаем миграцию:
`poetry run python manage.py makemigrations`
Django сгенерирует новый файл миграции (например, `0002_master_phone.py`), который будет содержать инструкции по добавлению поля `phone` в таблицу `core_master`, разрешая `NULL` значения.

Затем применяем эту миграцию:
`poetry run python manage.py migrate`
Теперь таблица `core_master` будет обновлена, и в ней появится новое поле `phone`, которое может содержать `NULL` значения.

## Откатить миграции

Иногда возникает необходимость откатить примененные миграции, например, для отмены изменений в схеме базы данных или для возврата к предыдущему состоянию. Django предоставляет возможность отката миграций для конкретного приложения или для всех приложений.

Для отката миграций используется команда `poetry run python manage.py migrate <app_label> <migration_name>`.

* `<app_label>`: Название приложения, миграции которого вы хотите откатить (например, `core`).
* `<migration_name>`: Имя миграции, до которой вы хотите откатиться. Это может быть полный номер миграции (например, `0001`) или `zero` для полного отката всех миграций приложения.

Примеры:

* **Откат до определенной миграции**:
    `poetry run python manage.py migrate core 0001`
    Эта команда откатит все миграции приложения `core` до миграции с номером `0001`. Если у вас были миграции `0002_master_phone.py`, `0003_another_change.py` и т.д., они будут отменены, и схема базы данных вернется к состоянию после применения миграции `0001_initial.py`.

* **Полный откат всех миграций приложения**:
    `poetry run python manage.py migrate core zero`
    Эта команда полностью откатит все миграции для приложения `core`, удалив все таблицы, связанные с этим приложением, из базы данных. Это полезно, когда вы хотите начать с чистого листа для определенного приложения.

При откате миграций Django выполняет обратные SQL-операции, которые были применены при создании миграций. Например, если миграция создавала таблицу, откат этой миграции удалит таблицу. Если миграция добавляла столбец, откат удалит этот столбец.

## Создание суперпользователя

После настройки моделей и применения миграций, часто требуется создать учетную запись суперпользователя для доступа к административной панели Django. Суперпользователь имеет полные права на управление всеми данными в приложении через встроенный административный интерфейс.

Для создания суперпользователя используется команда:
`poetry run python manage.py createsuperuser`

При выполнении этой команды вам будет предложено ввести имя пользователя, адрес электронной почты (необязательно) и пароль для новой учетной записи суперпользователя. После успешного создания вы сможете войти в административную панель Django (обычно доступную по адресу `/admin/` после запуска сервера разработки) и начать управлять данными ваших моделей.

## Свойства полей

При определении полей модели в Django, вы можете использовать различные типы полей, каждый из которых соответствует определенному типу данных в базе данных и имеет свои специфические параметры.

### Большая сводная таблица типов полей

| Название типа поля | Описание | Основные параметры |
| :----------------- | :------- | :------------------ |
| `CharField`        | Строковое поле для хранения коротких и средних строк текста. | `max_length` (обязательный): максимальная длина строки. |
| `TextField`        | Текстовое поле для хранения больших объемов текста. | Не требует `max_length`. |
| `IntegerField`     | Целочисленное поле. | `null`, `blank`, `default`. |
| `BooleanField`     | Логическое поле (True/False). | `default`. |
| `DateField`        | Поле для хранения даты. | `auto_now`, `auto_now_add`, `default`. |
| `DateTimeField`    | Поле для хранения даты и времени. | `auto_now`, `auto_now_add`, `default`. |
| `EmailField`       | Поле для хранения адресов электронной почты. Наследуется от `CharField` и выполняет проверку формата email. | `max_length` (обязательный). |
| `URLField`         | Поле для хранения URL-адресов. Наследуется от `CharField` и выполняет проверку формата URL. | `max_length` (обязательный). |
| `ForeignKey`       | Поле для определения связи "один-ко-многим" с другой моделью. | `on_delete` (обязательный): определяет поведение при удалении связанного объекта. |
| `ManyToManyField`  | Поле для определения связи "многие-ко-многим" с другой моделью. | `through` (опционально): для промежуточной модели. |
| `OneToOneField`    | Поле для определения связи "один-к-одному" с другой моделью. | `on_delete` (обязательный). |

### Большая сводная таблица характеристик полей

Помимо типов полей, существуют общие характеристики (параметры), которые можно применять к большинству полей модели для настройки их поведения и ограничений.

| Название параметра | Описание | Примеры использования |
| :----------------- | :------- | :-------------------- |
| `max_length`       | Максимальная длина поля в символах. Обязателен для `CharField`, `EmailField`, `URLField`. | `CharField(max_length=100)` |
| `null`             | Если `True`, Django будет хранить `NULL` в базе данных для пустых значений. По умолчанию `False`. | `CharField(null=True)` |
| `blank`            | Если `True`, поле может быть пустым в формах (например, в Django Admin). По умолчанию `False`. | `CharField(blank=True)` |
| `default`          | Значение по умолчанию для поля. Может быть как статическим значением, так и вызываемым объектом. | `CharField(default="N/A")`, `IntegerField(default=0)` |
| `verbose_name`     | Человекочитаемое название поля, используемое в Django Admin и формах. | `CharField(verbose_name="Имя пользователя")` |
| `help_text`        | Дополнительный текст, отображаемый в виджете формы для поля. | `CharField(help_text="Введите ваше полное имя")` |
| `unique`           | Если `True`, значение поля должно быть уникальным по всей таблице. | `EmailField(unique=True)` |
| `db_index`         | Если `True`, для этого поля будет создан индекс в базе данных, что ускоряет поиск. | `CharField(db_index=True)` |
| `primary_key`      | Если `True`, это поле будет первичным ключом модели. По умолчанию Django автоматически создает `id` как первичный ключ. | `UUIDField(primary_key=True)` |
| `auto_now`         | Автоматически обновляет поле до текущей даты/времени при каждом сохранении объекта. Используется для `DateField` и `DateTimeField`. | `DateTimeField(auto_now=True)` |
| `auto_now_add`     | Автоматически устанавливает поле до текущей даты/времени при первом создании объекта. Используется для `DateField` и `DateTimeField`. | `DateTimeField(auto_now_add=True)` |
| `on_delete`        | Определяет поведение при удалении объекта, на который ссылается `ForeignKey` или `OneToOneField`. | `models.CASCADE`, `models.PROTECT`, `models.SET_NULL`, `models.SET_DEFAULT`, `models.DO_NOTHING`, `models.RESTRICT` |

### `null = True` и `blank = True`

Эти два параметра часто путают, но они имеют разные назначения:

* **`null=True`**: Этот параметр относится к базе данных. Если `null=True`, то в соответствующем столбце базы данных разрешено хранить `NULL` значения. Если `null=False` (по умолчанию), то поле не может быть `NULL` в базе данных, и при попытке сохранить объект с пустым значением для этого поля будет сгенерирована ошибка базы данных.
* **`blank=True`**: Этот параметр относится к валидации форм (включая Django Admin). Если `blank=True`, то поле может быть оставлено пустым при заполнении формы. Если `blank=False` (по умолчанию), то поле является обязательным для заполнения в форме.

**Ключевое отличие**:

* `null` влияет на схему базы данных.
* `blank` влияет на валидацию форм.

Например, если у вас есть `CharField(null=True, blank=False)`, это означает, что поле может быть `NULL` в базе данных, но оно обязательно для заполнения в форме. Это может быть полезно, если вы хотите, чтобы поле было необязательным для программного создания объектов, но обязательным для ввода через пользовательский интерфейс.

### Можно ли поставить `default=None` но не ставить `null=True`?

Нет, нельзя. Если вы пытаетесь установить `default=None` для поля, которое не разрешает `NULL` значения в базе данных (то есть `null=False`), Django выдаст ошибку.

Причина в том, что `None` в Python интерпретируется как `NULL` в базе данных. Если поле определено как `null=False`, база данных не позволит вставить `NULL` значение. Поэтому, если вы хотите, чтобы поле могло иметь значение `None` по умолчанию, вы **обязательно** должны установить `null=True` для этого поля.

Например, `phone = models.CharField(max_length=20, default=None)` без `null=True` приведет к ошибке, так как `CharField` по умолчанию `null=False`. Правильный способ сделать поле необязательным и с `None` по умолчанию: `phone = models.CharField(max_length=20, null=True, default=None)`.

## Завершили модель `Master`

Теперь, когда мы разобрались со свойствами полей, давайте завершим нашу модель `Master`, добавив все необходимые поля и мета-опции, как это показано в файле `core/models.py`:

```python
from django.db import models


class Master(models.Model):
    first_name = models.CharField(max_length=100, verbose_name="Имя")
    last_name = models.CharField(max_length=100, verbose_name="Фамилия")
    middle_name = models.CharField(
        null=True, blank=True, max_length=100, verbose_name="Отчество"
    )
    phone = models.CharField(max_length=20, verbose_name="Телефон", default="00000000000")
    email = models.EmailField(null=True, blank=True, verbose_name="Email")

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

    class Meta:
        # на русском языке - в ед. числе и мн. числе
        verbose_name = "Мастер"
        verbose_name_plural = "Мастера"
        # сортировка по фамилии и имени
        ordering = ["last_name", "first_name"]
```

В этой версии модели `Master` мы добавили:

* `verbose_name` для каждого поля, что делает их более понятными в административной панели.
* Поле `middle_name` сделано необязательным (`null=True, blank=True`), так как отчество может отсутствовать.
* Поле `phone` имеет значение по умолчанию `"00000000000"`, что полезно для предотвращения ошибок при добавлении новых записей, если телефон не указан.
* Поле `email` также сделано необязательным.
* Метод `__str__` для удобного строкового представления объекта `Master`.
* Вложенный класс `Meta`, который определяет мета-опции модели:
  * `verbose_name` и `verbose_name_plural` для человекочитаемых названий модели в единственном и множественном числе.
  * `ordering` для сортировки записей по фамилии, а затем по имени по умолчанию.

## Подключим модель `Master` к админке

Чтобы управлять записями модели `Master` через встроенную административную панель Django, нам необходимо зарегистрировать ее в файле `core/admin.py`. Самый простой способ регистрации — это использование функции `admin.site.register()`.

Откроем файл `core/admin.py` и добавим следующий код:

```python
from django.contrib import admin
from .models import Master

# Register your models here.
admin.site.register(Master)
```

После сохранения этого файла и запуска сервера разработки (`poetry run python manage.py runserver`), вы сможете увидеть модель `Master` в административной панели Django (обычно по адресу `/admin/`).

На следующем изображении показано, как выглядит список мастеров в административной панели Django после регистрации модели. Мы видим заголовок "Выбрать мастера для изменения", а также список существующих записей, если они есть. Название "Мастера" берется из `verbose_name_plural`, определенного в классе `Meta` модели `Master`.

![admin_master.png](./images/admin_master.png)

Это изображение подтверждает успешную регистрацию модели `Master` в административной панели, что позволяет легко добавлять, изменять и удалять записи.

Этот этап соответствует коммиту: `lesson_54: реристрация модели в админке`.

## Таблица `Order`

Теперь давайте создадим вторую модель — `Order`, которая будет представлять собой запись о заказе. Эта модель будет иметь связь с моделью `Master` через внешний ключ. Добавим следующий код в `core/models.py`:

```python
from django.db import models


class Master(models.Model):
    first_name = models.CharField(max_length=100, verbose_name="Имя")
    last_name = models.CharField(max_length=100, verbose_name="Фамилия")
    middle_name = models.CharField(
        null=True, blank=True, max_length=100, verbose_name="Отчество"
    )
    phone = models.CharField(max_length=20, verbose_name="Телефон", default="00000000000")
    email = models.EmailField(null=True, blank=True, verbose_name="Email")

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

    class Meta:
        # на русском языке - в ед. числе и мн. числе
        verbose_name = "Мастер"
        verbose_name_plural = "Мастера"
        # сортировка по фамилии и имени
        ordering = ["last_name", "first_name"]


class Order(models.Model):
    name = models.CharField(max_length=100, verbose_name="Имя")
    phone = models.CharField(max_length=20, verbose_name="Телефон")
    comment = models.TextField(verbose_name="Комментарий", null=True, blank=True)
    master = models.ForeignKey(Master, verbose_name="Мастер", default=None, on_delete=models.SET_DEFAULT)
```

В модели `Order` мы определили следующие поля:

* `name`: Имя клиента.
* `phone`: Телефон клиента.
* `comment`: Комментарий к заказу, необязательное текстовое поле.
* `master`: Это `ForeignKey` (внешний ключ) к модели `Master`. Это означает, что каждый заказ связан с одним мастером.

**Пояснение про `on_delete=models.SET_DEFAULT`**:
Параметр `on_delete` в `ForeignKey` определяет, что произойдет с записями `Order`, если связанный объект `Master` будет удален.

* `models.SET_DEFAULT`: Это очень важный параметр для бизнеса. Он означает, что если мастер, связанный с заказом, будет удален, то поле `master` в записи `Order` будет установлено в значение, указанное в `default`. В нашем случае, `default=None`.
* **Почему для бизнеса важно НЕ удалять данные при удалении мастера?** Представьте, что у вас есть история заказов. Если вы удалите мастера, и все его заказы также будут удалены (`models.CASCADE`), вы потеряете ценную информацию о прошлых услугах, доходах и клиентах. `SET_DEFAULT` позволяет сохранить записи заказов, даже если мастер уволился или был удален из системы. Это обеспечивает целостность исторических данных.
* **Что будет происходить с записью при удалении мастера?** При удалении мастера, все заказы, которые были связаны с этим мастером, останутся в базе данных, но их поле `master` будет установлено в `NULL` (поскольку `default=None` и `null=True` для внешних ключей по умолчанию, если `default` не является `None`). Это позволяет сохранить информацию о заказе, даже если конкретный мастер больше не существует в системе.

**Мы не поставили тут `blank=True` почему?**
Обратите внимание, что для поля `master` мы не установили `blank=True`. Это означает, что поле `master` является **обязательным** для заполнения в формах. То есть, при создании нового заказа через административную панель или любую другую форму, вы **обязаны** выбрать мастера. Это сделано намеренно, чтобы каждый заказ всегда был привязан к какому-либо мастеру, что логично для бизнес-процесса.

### Регистрация модели `Order` в админке

Как и для модели `Master`, нам нужно зарегистрировать модель `Order` в административной панели. Обновим файл `core/admin.py`:

```python
from django.contrib import admin
from .models import Master, Order

# Register your models here.
admin.site.register(Master)
admin.site.register(Order)
```

### Создание и применение миграций

После добавления новой модели `Order` и ее регистрации в админке, необходимо создать и применить новые миграции:

1. **Создание миграции**:
    `poetry run python manage.py makemigrations`
    Эта команда сгенерирует новый файл миграции (например, `0003_order.py`), который будет содержать инструкции для создания таблицы `core_order` и настройки внешнего ключа.

2. **Применение миграции**:
    `poetry run python manage.py migrate`
    Эта команда применит новую миграцию к базе данных, создав таблицу `core_order`.

Так как мы специально не стали для внешнего ключа `master` добавлять `blank=True`, то при создании записи `Order` в админке мы не сможем оставить поле "Мастер" пустым. Django Admin автоматически создаст выпадающий список для выбора мастера, и это поле будет помечено как обязательное.

На следующем изображении показана форма создания нового заказа в административной панели Django. Мы видим поля "Имя", "Телефон", "Комментарий" и "Мастер". Поле "Мастер" является выпадающим списком, и оно обязательно для заполнения, что подтверждается отсутствием опции "Оставить пустым" или "Нет".

![order_detail_form.png](./images/order_detail_form.png)

Это изображение демонстрирует, что поле "Мастер" является обязательным для заполнения при создании заказа, что соответствует нашему дизайну модели.

Этот этап соответствует коммиту: `lesson_54: модель Order`.

## Django Shell Plus

Django предоставляет интерактивную оболочку (shell), которая позволяет вам взаимодействовать с вашим проектом Django, включая модели, менеджеры и другие компоненты, прямо из командной строки. Это очень удобно для тестирования, отладки и выполнения быстрых операций с данными.

### Что такое обычный Django Shell

Обычный Django Shell запускается командой `poetry run python manage.py shell`. Он предоставляет стандартную Python-оболочку с уже загруженными настройками вашего Django проекта. Вы можете импортировать свои модели и выполнять запросы к базе данных, создавать объекты и т.д.

### Чем сторонний пакет будет лучше?

Хотя стандартный Django Shell функционален, сторонний пакет `django-extensions` предоставляет улучшенную версию оболочки под названием `shell_plus`. `shell_plus` автоматически импортирует все ваши модели из всех установленных приложений, что избавляет вас от необходимости вручную импортировать каждую модель перед использованием. Это значительно ускоряет и упрощает работу в интерактивной среде.

### Установка `shell_plus`

Для использования `shell_plus` сначала необходимо установить пакет `django-extensions`:

`poetry add django-extensions`

После установки пакета, его необходимо подключить в настройках вашего проекта. Откройте файл `barbershop/settings.py` и добавьте `"django_extensions"` в список `INSTALLED_APPS`:

```python
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # Мои приложения
    "core",
    # Сторонние приложения
    "django_extensions", # Добавляем django-extensions
]
```

Этот этап соответствует коммиту: `lesson_54: Установка Shell Plus`.

### Запуск `shell_plus`

После установки и настройки `django-extensions`, вы можете запустить `shell_plus` командой:

`poetry run python manage.py shell_plus`

Вы увидите приветственное сообщение, и оболочка будет готова к работе.

На следующем изображении показан запуск `shell_plus` в терминале. Видно, что оболочка успешно запущена и готова к приему команд.

![shell_plus.png](./images/shell_plus.png)

Это изображение подтверждает успешный запуск `shell_plus`, который автоматически импортировал все модели, включая `Master` и `Order`.

### Первые запросы

Теперь, когда `shell_plus` запущен, вы можете легко взаимодействовать с вашими моделями. Вот несколько примеров простых запросов:

* **Простая выборка всех объектов модели `Order`**:
    Вы можете получить все объекты модели `Order` с помощью `Order.objects.all()`. Эта команда возвращает `QuerySet` — это коллекция объектов, которая еще не выполнила запрос к базе данных. Запрос к базе данных выполняется только тогда, когда вы пытаетесь получить доступ к элементам `QuerySet` (например, при итерации или обращении по индексу).

```python
orders = Order.objects.all()
```

* **Получение экземпляра объекта из `QuerySet`**:
    Если вы обратитесь к элементу `QuerySet` по индексу, например `orders[0]`, вы получите конкретный экземпляр объекта `Order`.

```python
first_order = orders[0]
```

* **Доступ к данным поля экземпляра**:
    Вы можете получить доступ к данным поля конкретного экземпляра, например, `first_order.name` может вернуть "Фродо", если это имя первого заказа.

```python
print(first_order.name) # Например, "Фродо"
```

* **Доступ к данным из связанной модели**:
    Это демонстрирует, как легко получить доступ к полям связанной модели (`Master`) через внешний ключ. Например, `first_order.master.first_name` вернет имя мастера, связанного с первым заказом.

```python
print(first_order.master.first_name) # Например, "Иван"
```

Эти примеры показывают, как удобно работать с данными моделей Django, используя `shell_plus`, что делает его мощным инструментом для разработки и отладки.
