# Lesson 51: Циклы и условия шаблонизатора

## BS5

Отлично! Давайте подробно разберем каждый из этих примеров Bootstrap 5, чтобы понять, как работает его адаптивная сеточная система.

Прежде чем мы начнем, важно помнить основные принципы сеточной системы Bootstrap:

* **Контейнеры (`.container` или `.container-fluid`)**: Это внешние обертки для вашего контента, которые обеспечивают правильное выравнивание и отступы. Хотя в ваших примерах их нет, они обычно используются для размещения строк.
* **Строки (`.row`)**: Строки являются обертками для столбцов. Они используют отрицательные поля для создания промежутков между столбцами (так называемые "gutter").
* **Столбцы (`.col`, `.col-sm-*`, `.col-md-*`, `.col-lg-*`, `.col-xl-*`, `.col-xxl-*`)**: Столбцы размещаются внутри строк. Bootstrap делит ширину строки на 12 условных частей. Вы можете указать, сколько из этих 12 частей должен занимать столбец.

Теперь перейдем к вашим примерам:

---

### Пример 1: Автоматическое распределение ширины столбцов

```html
<div class="row">
    <div class="col">1</div>
    <div class="col">2</div>
    <div class="col">3</div>
</div>
```

**Детальное пояснение:**

1. **`<div class="row">`**: Это определяет новую строку в сеточной системе Bootstrap. Все дочерние элементы, которые являются столбцами, будут располагаться горизонтально внутри этой строки.
2. **`<div class="col">` (без указания числа)**: Это ключевой момент. Когда вы используете класс `col` без числового суффикса (например, `col-4` или `col-md-6`), Bootstrap автоматически распределяет доступную ширину строки поровну между всеми такими столбцами в этой строке.
    * В данном случае у вас три столбца с классом `col`. Поскольку общая ширина строки делится на 12 частей, и у вас 3 таких столбца, каждый столбец займет `12 / 3 = 4` условные части ширины.
    * Таким образом, на **любом размере экрана** (от самых маленьких мобильных устройств до больших десктопов) каждый из этих трех блоков (`1`, `2`, `3`) будет занимать ровно одну треть доступной ширины строки.
    * Это очень удобно для создания равномерных макетов, где вам не нужно беспокоиться о конкретных размерах экрана.

**Визуальный результат:**
На всех устройствах:
`[ Блок 1 (1/3) ] [ Блок 2 (1/3) ] [ Блок 3 (1/3) ]`

---

### Пример 2: Фиксированная ширина столбца и заполнение оставшегося пространства

```html
<div class="row">
    <div class="col-8">8 из 12</div>
    <div class="col">Остальное</div>
</div>
```

**Детальное пояснение:**

1. **`<div class="row">`**: Снова, это определяет новую строку.
2. **`<div class="col-8">`**: Этот столбец явно указывает, что он должен занимать 8 из 12 условных частей ширины строки.
    * Как и в первом примере, когда вы используете `col-*` без префикса размера экрана (например, `col-md-`), это означает, что данное правило применяется ко **всем размерам экрана** (от `xs` до `xxl`).
3. **`<div class="col">` (без указания числа)**: Этот столбец снова использует автоматическое распределение. Однако, в отличие от первого примера, здесь уже есть столбец с фиксированной шириной (`col-8`).
    * Bootstrap сначала выделяет место для столбцов с явно заданной шириной. В данном случае `col-8` занимает 8 частей.
    * Остается `12 - 8 = 4` условные части ширины.
    * Поскольку у нас только один столбец с классом `col` (без числа), он займет все оставшиеся 4 части.
    * Таким образом, на **любом размере экрана** первый блок будет занимать 8/12 (или 2/3) ширины, а второй блок — 4/12 (или 1/3) ширины.

**Визуальный результат:**
На всех устройствах:
`[ Блок "8 из 12" (2/3) ] [ Блок "Остальное" (1/3) ]`

---

### Пример 3: Адаптивные столбцы с использованием брейкпоинтов

```html
<div class="row">
    <div class="col-12 col-md-8">8 из 12</div>
    <div class="col-12 col-md-4">Остальное</div>
</div>
```

**Детальное пояснение:**

Этот пример демонстрирует мощь адаптивного дизайна Bootstrap с использованием **брейкпоинтов (breakpoints)**. Bootstrap имеет пять стандартных брейкпоинтов:

* `xs` (extra small): < 576px (по умолчанию, используется `col-*`)
* `sm` (small): ≥ 576px
* `md` (medium): ≥ 768px
* `lg` (large): ≥ 992px
* `xl` (extra large): ≥ 1200px
* `xxl` (extra extra large): ≥ 1400px

Правила для брейкпоинтов работают по принципу "снизу вверх": если вы определяете класс для `md`, он будет применяться ко всем размерам экрана, начиная с `md` и выше (`md`, `lg`, `xl`, `xxl`), пока не будет переопределен более крупным брейкпоинтом.

Давайте разберем каждый столбец:

**Первый столбец: `<div class="col-12 col-md-8">8 из 12</div>`**

* **`col-12`**: Это правило применяется к самым маленьким экранам (extra small, `xs`) и всем экранам, которые меньше брейкпоинта `md` (т.е. `xs` и `sm`). На этих экранах данный блок будет занимать **всю ширину строки (12 из 12 частей)**. Это означает, что он будет располагаться на отдельной строке.
* **`col-md-8`**: Это правило начинает действовать, когда ширина экрана достигает или превышает брейкпойнт `md` (768px). На экранах `md`, `lg`, `xl`, `xxl` этот блок будет занимать **8 из 12 частей ширины строки**.

**Второй столбец: `<div class="col-12 col-md-4">Остальное</div>`**

* **`col-12`**: Аналогично первому столбцу, на экранах `xs` и `sm` этот блок будет занимать **всю ширину строки (12 из 12 частей)**. Он также будет располагаться на отдельной строке, под первым блоком.
* **`col-md-4`**: На экранах `md` и выше этот блок будет занимать **4 из 12 частей ширины строки**.

**Комбинированный результат:**

* **На маленьких экранах (xs, sm - до 768px):**
  * Оба блока будут занимать по 12 колонок, то есть каждый будет располагаться на своей отдельной строке.
  * `[ Блок "8 из 12" (100%) ]`
  * `[ Блок "Остальное" (100%) ]`
* **На средних и больших экранах (md, lg, xl, xxl - от 768px и выше):**
  * Первый блок займет 8 колонок, а второй — 4 колонки. Они будут располагаться рядом в одной строке.
  * `[ Блок "8 из 12" (2/3) ] [ Блок "Остальное" (1/3) ]`

Это очень распространенный паттерн для создания адаптивных макетов, где элементы "складываются" в вертикальный стек на мобильных устройствах и располагаются горизонтально на больших экранах.

---

### Пример 4: Более сложный адаптивный макет с несколькими брейкпоинтами

```html
<div class="row">
    <div class="col-12 col-md-6 col-lg-4">Блок 1</div>
    <div class="col-12 col-md-6 col-lg-4">Блок 2</div>
    <div class="col-12 col-md-6 col-lg-4">Блок 3</div>
</div>
```

**Детальное пояснение:**

Этот пример демонстрирует, как вы можете управлять расположением столбцов на трех разных уровнях брейкпоинтов, создавая динамичный и гибкий макет.

Давайте разберем один из столбцов, так как все три имеют одинаковые классы:
**`<div class="col-12 col-md-6 col-lg-4">Блок X</div>`**

* **`col-12`**:
  * **На самых маленьких экранах (xs, sm - до 768px):** Каждый блок будет занимать **всю ширину строки (12 из 12 частей)**. Это означает, что все три блока будут располагаться друг под другом, каждый на своей отдельной строке.
* **`col-md-6`**:
  * **На средних экранах (md - от 768px до 992px):** Каждый блок будет занимать **6 из 12 частей ширины строки**. Поскольку 6 + 6 = 12, это означает, что два блока будут располагаться рядом в одной строке, а третий блок перенесется на следующую строку.
* **`col-lg-4`**:
  * **На больших экранах (lg, xl, xxl - от 992px и выше):** Каждый блок будет занимать **4 из 12 частей ширины строки**. Поскольку 4 + 4 + 4 = 12, это означает, что все три блока будут располагаться рядом в одной строке.

**Комбинированный результат:**

* **На очень маленьких и маленьких экранах (xs, sm - до 768px):**
  * `[ Блок 1 (100%) ]`
  * `[ Блок 2 (100%) ]`
  * `[ Блок 3 (100%) ]`
    (Все блоки располагаются вертикально, каждый на своей строке)

* **На средних экранах (md - от 768px до 992px):**
  * `[ Блок 1 (50%) ] [ Блок 2 (50%) ]`
  * `[ Блок 3 (50%) ]`
    (Два блока в первой строке, третий блок переносится на новую строку и занимает 50% ширины)

* **На больших и очень больших экранах (lg, xl, xxl - от 992px и выше):**
  * `[ Блок 1 (33.3%) ] [ Блок 2 (33.3%) ] [ Блок 3 (33.3%) ]`
    (Все три блока располагаются горизонтально в одной строке)

Этот пример прекрасно иллюстрирует, как Bootstrap позволяет вам создавать сложные, но интуитивно понятные адаптивные макеты, которые автоматически подстраиваются под различные размеры экранов, обеспечивая оптимальное отображение контента для пользователя.

## Цикл в шаблонизаторе с bs5 полосой и колонками

![Скриншот кода](./images/bs5_for_template.png)

Отлично! Давайте разберем этот скриншот по частям, чтобы понять, как работает это Django-приложение, отображающее список мастеров, с использованием Bootstrap 5 для адаптивного макета.

На скриншоте представлены следующие файлы и их содержимое:

1. **`core/data.py`**: Источник данных (список мастеров).
2. **`barbershop/urls.py`**: Конфигурация URL-адресов проекта.
3. **`core/views.py`**: Логика обработки запросов и подготовки данных.
4. **`templates/master_list.html`**: Шаблон для отображения списка мастеров.
5. **`static/css/main.css`**: Пользовательские стили.

Давайте пройдемся по каждому файлу и объясним его роль.

---

### 1. `core/data.py` (Источник данных)

```python
1 masters: list[dict[str, Any]] = [
2     {"id": 1, "name": "Эльдар 'Бритва' Рязанов"},
3     {"id": 2, "name": "Зоя 'Ножницы' Космодемьянская"},
4     {"id": 3, "name": "Борис 'Фен' Пастернак"},
5     {"id": 4, "name": "Иннокентий 'Лак' Смоктуновский"},
6     {"id": 5, "name": "Раиса 'Бигуди' Горбачёва"},
7 ]
```

* **Назначение**: Этот файл служит простым "хранилищем" данных для демонстрации. В реальном приложении эти данные, скорее всего, извлекались бы из базы данных (например, через Django ORM).
* **Содержимое**: Определена переменная `masters`, которая является списком словарей. Каждый словарь представляет собой одного мастера и содержит два ключа:
  * `"id"`: Уникальный идентификатор мастера.
  * `"name"`: Имя мастера.
* **Использование**: Этот список `masters` будет импортирован в `views.py` и передан в шаблон для отображения.

---

### 2. `barbershop/urls.py` (Конфигурация URL-адресов)

```python
8 urlpatterns: list[Any] = [
9     path("admin/", admin.site.urls),
10    path("", index),
11    path("masters/", master_list, name="master_list"),
12    path("masters/<int:master_id>/", master_detail),
13 ] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

* **Назначение**: Этот файл сопоставляет URL-адреса с соответствующими функциями-представлениями (views) в вашем приложении.
* **Строка 11: `path("masters/", master_list, name="master_list"),`**
  * Когда пользователь переходит по URL `/masters/` (например, `http://localhost:8000/masters/`), Django вызывает функцию `master_list`.
  * `name="master_list"`: Это имя позволяет ссылаться на этот URL в шаблонах или коде Django, не жестко прописывая сам URL. Это делает код более гибким и устойчивым к изменениям URL.
* **Строка 12: `path("masters/<int:master_id>/", master_detail),`**
  * Это пример динамического URL. Если пользователь переходит по `/masters/1/` или `/masters/5/`, Django вызывает функцию `master_detail` и передает ей числовое значение (`1` или `5`) как аргумент `master_id`. Это используется для отображения деталей конкретного мастера.

---

### 3. `core/views.py` (Логика представления)

```python
29 def master_list(request) -> HttpResponse:
30     context: dict[str, list[dict[str, Any]]] = {
31         "masters": masters,
32     }
33     return render(request, "master_list.html", context)
```

* **Назначение**: Эта функция (`master_list`) является "представлением" (view) в архитектуре Django. Она обрабатывает HTTP-запрос, подготавливает данные и отправляет их в шаблон для рендеринга.
* **`def master_list(request) -> HttpResponse:`**: Определяет функцию `master_list`, которая принимает объект `request` (содержащий информацию о входящем HTTP-запросе) и должна возвращать объект `HttpResponse`.
* **`context: dict[str, list[dict[str, Any]]] = { "masters": masters, }`**:
  * Здесь создается словарь `context`. Этот словарь содержит данные, которые будут переданы в шаблон.
  * Ключ `"masters"` сопоставляется со списком `masters`, импортированным из `data.py`. Таким образом, в шаблоне мы сможем получить доступ к этому списку через переменную `masters`.
* **`return render(request, "master_list.html", context)`**:
  * Это основная функция для рендеринга шаблонов в Django.
  * Она принимает `request`, путь к файлу шаблона (`"master_list.html"`) и словарь `context`.
  * Django берет шаблон, заполняет его данными из `context` и возвращает готовый HTML-код в виде `HttpResponse`, который затем отправляется в браузер пользователя.

---

### 4. `templates/master_list.html` (Шаблон HTML с Bootstrap)

```html
8 <div class="row g-3">
9     {% for master in masters %}
10        <div class="col-12 col-md-6 col-lg-4">
11            <div class="master-card">
12                <p>ID Мастера: {{ master.id }}</p>
13                <p>Имя Мастера: {{ master.name }}</p>
14            </div>
15        </div>
16    {% endfor %}
17 </div>
```

* **Назначение**: Этот файл содержит HTML-структуру страницы и использует шаблонизатор Django для вставки динамических данных. Здесь также активно используются классы Bootstrap 5 для создания адаптивного макета.
* **Строка 8: `<div class="row g-3">`**
  * `row`: Это базовый класс Bootstrap для создания строки в сеточной системе. Все столбцы (`.col-*`) должны быть внутри `.row`.
  * `g-3`: Это класс Bootstrap 5 для управления "gutter" (промежутками) между столбцами. `g-3` устанавливает промежуток в 1rem (16px по умолчанию) как по горизонтали, так и по вертикали между столбцами. Это обеспечивает визуальное разделение между карточками мастеров.
* **Строка 9: `{% for master in masters %}`**
  * Это тег цикла шаблонизатора Django. Он будет итерироваться по каждому элементу в списке `masters`, который был передан из `views.py`.
  * На каждой итерации переменная `master` будет содержать один словарь мастера (например, `{"id": 1, "name": "Эльдар 'Бритва' Рязанов"}`).
* **Строка 10: `<div class="col-12 col-md-6 col-lg-4">`**
  * Это столбец Bootstrap, который будет содержать карточку каждого мастера. Классы здесь определяют его адаптивное поведение:
    * `col-12`: На очень маленьких и маленьких экранах (до 768px) каждый блок будет занимать **всю ширину строки (12 из 12 колонок)**. Это означает, что каждый мастер будет отображаться на отдельной строке.
    * `col-md-6`: На средних экранах (от 768px до 992px) каждый блок будет занимать **6 из 12 колонок**. Это означает, что два мастера будут располагаться рядом в одной строке (6 + 6 = 12), а остальные будут переноситься на новые строки.
    * `col-lg-4`: На больших и очень больших экранах (от 992px и выше) каждый блок будет занимать **4 из 12 колонок**. Это означает, что три мастера будут располагаться рядом в одной строке (4 + 4 + 4 = 12).
* **Строка 11: `<div class="master-card">`**
  * Это пользовательский класс, который будет стилизован в `main.css` для придания карточке мастера определенного внешнего вида (фон, скругленные углы, отступы, тень).
* **Строки 12-13: `<p>ID Мастера: {{ master.id }}</p>` и `<p>Имя Мастера: {{ master.name }}</p>`**
  * Это вывод динамических данных. `{{ master.id }}` и `{{ master.name }}` — это переменные шаблона Django, которые будут заменены соответствующими значениями из текущего объекта `master` в цикле.
* **Строка 16: `{% endfor %}`**: Закрывает цикл `for`.

---

### 5. `static/css/main.css` (Пользовательские стили)

```css
1 body {
2     background-color: rgb(218, 255, 255);
3 }
6 .master-card {
7     background-color: rgb(255, 255, 255);
8     border-radius: 10px;
9     padding: 20px;
10    /* margin: 10px; */
11    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
12 }
```

* **Назначение**: Этот файл содержит пользовательские CSS-стили, которые применяются к элементам на странице.
* **`body`**:
  * `background-color: rgb(218, 255, 255);`: Устанавливает очень светлый голубовато-зеленый цвет фона для всей страницы.
* **`.master-card`**:
  * `background-color: rgb(255, 255, 255);`: Устанавливает белый цвет фона для каждой карточки мастера.
  * `border-radius: 10px;`: Скругляет углы карточки на 10 пикселей, делая их более мягкими.
  * `padding: 20px;`: Добавляет внутренний отступ в 20 пикселей со всех сторон внутри карточки, чтобы контент (ID и имя) не прилипал к краям.
  * `box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);`: Добавляет легкую тень к карточке, создавая эффект глубины и отделяя ее от фона. (Закомментированный `margin: 10px;` мог бы добавить внешний отступ, но `g-3` из Bootstrap уже справляется с промежутками).

---

### Как это все работает вместе

1. **Запрос пользователя**: Пользователь открывает браузер и вводит URL `http://localhost:8000/masters/`.
2. **Маршрутизация (urls.py)**: Django получает этот запрос, смотрит в `barbershop/urls.py` и находит, что URL `/masters/` соответствует функции `master_list` в `views.py`.
3. **Обработка запроса (views.py)**:
    * Функция `master_list` вызывается.
    * Она импортирует список `masters` из `data.py`.
    * Создает `context` словарь, передавая этот список под ключом `"masters"`.
    * Вызывает `render`, указывая шаблон `master_list.html` и `context`.
4. **Рендеринг шаблона (master_list.html)**:
    * Django начинает обрабатывать `master_list.html`.
    * Он видит цикл `{% for master in masters %}` и начинает итерироваться по каждому мастеру из списка.
    * Для каждого мастера создается новый `div` с классами `col-12 col-md-6 col-lg-4`, который обеспечивает адаптивное расположение.
    * Внутри этого `div` создается `div` с классом `master-card`.
    * Значения `master.id` и `master.name` вставляются в соответствующие параграфы.
    * После завершения цикла, Django собирает весь сгенерированный HTML.
5. **Применение стилей (main.css)**: Браузер получает HTML-код, а также ссылки на статические файлы, включая `main.css`. Он применяет стили, определенные в `main.css`, к элементам с классами `body` и `master-card`, придавая им визуальный вид.
6. **Отображение**: Браузер отображает готовую страницу со списком мастеров, где карточки автоматически перестраиваются в зависимости от ширины экрана благодаря классам Bootstrap.

Таким образом, этот набор файлов демонстрирует базовый, но функциональный подход к созданию динамических, адаптивных веб-страниц с использованием Django и Bootstrap 5.

## Ветвление в шаблонизаторе

Отлично! Давайте подробно разберем этот скриншот, который демонстрирует использование условной логики в шаблонах Django и применение классов Bootstrap для стилизации.

На скриншоте представлены следующие файлы и их содержимое:

1. **`core/views.py`**: Логика обработки запроса и подготовки данных.
2. **`templates/first_template.html`**: Шаблон для отображения данных с условной логикой.
3. **`static/css/main.css`**: (Виден только таб, но подразумевается, что он содержит стили для `.master-card`).

Давайте пройдемся по каждому файлу и объясним его роль.

---

### 1. `core/views.py` (Логика представления)

```python
9 def index(request) -> HttpResponse:
10     context: dict[str, dict[str, Any]] = {
11         "user": {
12             "name": "Сергей",
13             "age": 30,
14             "is_stuff": True
15         }
16     }
17     return render(request, "first_template.html", context)
```

* **Назначение**: Эта функция (`index`) является представлением Django, которое обрабатывает HTTP-запрос для главной страницы (или страницы, связанной с этим представлением). Она подготавливает данные о "пользователе" и передает их в шаблон.
* **Строка 9: `def index(request) -> HttpResponse:`**: Определяет функцию `index`, которая принимает объект `request` и возвращает `HttpResponse`.
* **Строки 10-15: `context: dict[str, dict[str, Any]] = { ... }`**:
  * Создается словарь `context`, который будет передан в шаблон.
  * Внутри `context` есть ключ `"user"`, значением которого является другой словарь, представляющий данные о пользователе.
  * Этот словарь `user` содержит:
    * `"name": "Сергей"`: Имя пользователя.
    * `"age": 30`: Возраст пользователя.
    * `"is_stuff": True`: Булево значение, которое, вероятно, указывает, является ли пользователь "сотрудником" или "персоналом" (от англ. "staff"). Это значение будет использоваться для условной логики в шаблоне.
* **Строка 17: `return render(request, "first_template.html", context)`**:
  * Функция `render` берет `request`, указанный шаблон (`"first_template.html"`) и словарь `context`.
  * Она заполняет шаблон данными из `context` и возвращает готовый HTML-код в браузер.

---

### 2. `templates/first_template.html` (Шаблон HTML с условной логикой)

```html
1 {% extends "base.html" %}

3 {% block content %}
4 <h1>Эксперимент с условием шаблонизатора</h1>

6 <div class="master-card">
7     <p>Имя: {{ user.name }}</p>
8     <p>Возраст: {{ user.age }}</p>
9     {% if user.is_stuff %}
10        {% comment %} BS5 бейдж {% endcomment %}
11        <p>Статус: <span class="badge bg-warning">Сотрудник</span></p>
12    {% elif user.is_admin %}
13        <p>Статус: <span class="badge bg-danger">Администратор</span></p>
14    {% else %}
15        <p>Статус: <span class="badge bg-secondary">Пользователь</span></p>
16    {% endif %}
17 </div>

19 {% endblock content %}
```

* **Назначение**: Этот шаблон отвечает за отображение информации о пользователе, используя данные, переданные из `views.py`, и применяя условную логику для определения статуса пользователя.
* **Строка 1: `{% extends "base.html" %}`**:
  * Это тег наследования шаблонов Django. Он указывает, что `first_template.html` расширяет (наследует) базовый шаблон `base.html`. Это позволяет переиспользовать общую структуру страницы (например, `<head>`, навигацию, футер) и вставлять уникальный контент в определенные "блоки".
* **Строка 3: `{% block content %}`**:
  * Это тег блока. Все, что находится между `{% block content %}` и `{% endblock content %}`, будет вставлено в соответствующий блок `content` в `base.html`. Это стандартный способ заполнения содержимого страницы.
* **Строка 4: `<h1>Эксперимент с условием шаблонизатора</h1>`**:
  * Простой заголовок первого уровня, который будет отображаться на странице.
* **Строка 6: `<div class="master-card">`**:
  * Это `div` элемент, который, как и в предыдущем примере, вероятно, стилизуется в `main.css` для придания ему вида "карточки" (фон, отступы, тень и т.д.).
* **Строки 7-8: `<p>Имя: {{ user.name }}</p>` и `<p>Возраст: {{ user.age }}</p>`**:
  * Это вывод динамических данных. `{{ user.name }}` и `{{ user.age }}` — это переменные шаблона Django, которые будут заменены соответствующими значениями из словаря `user`, переданного из `views.py`.
* **Строка 9: `{% if user.is_stuff %}`**:
  * Начало условного оператора `if` в шаблоне Django. Проверяет, является ли значение `user.is_stuff` истинным (True).
  * В данном случае, поскольку в `views.py` `is_stuff` установлено в `True`, этот блок кода будет выполнен.
* **Строка 10: `{% comment %} BS5 бейдж {% endcomment %}`**:
  * Это тег комментария шаблона Django. Все, что находится внутри `{% comment %}` и `{% endcomment %}`, игнорируется шаблонизатором и не попадает в итоговый HTML. Это полезно для заметок разработчика.
* **Строка 11: `<p>Статус: <span class="badge bg-warning">Сотрудник</span></p>`**:
  * Если `user.is_stuff` истинно, отображается этот параграф.
  * `<span class="badge bg-warning">Сотрудник</span>`: Здесь используются классы Bootstrap 5 для создания "бейдж" (badge) — небольшого, стилизованного элемента, часто используемого для меток или статусов.
    * `badge`: Базовый класс для бейджа.
    * `bg-warning`: Устанавливает цвет фона бейджа в "предупреждающий" (обычно желтый/оранжевый) цвет, определенный в Bootstrap.
* **Строка 12: `{% elif user.is_admin %}`**:
  * Это часть условного оператора `if/elif/else`. Если `user.is_stuff` было ложным, то проверяется условие `user.is_admin`.
  * В данном случае, `user.is_admin` не было передано в контексте, поэтому по умолчанию оно будет считаться ложным, и этот блок не будет выполнен.
* **Строка 13: `<p>Статус: <span class="badge bg-danger">Администратор</span></p>`**:
  * Если `user.is_admin` истинно, отображается этот параграф.
  * `bg-danger`: Устанавливает цвет фона бейджа в "опасный" (обычно красный) цвет.
* **Строка 14: `{% else %}`**:
  * Если ни одно из предыдущих условий (`if user.is_stuff` или `elif user.is_admin`) не было истинным, выполняется этот блок.
* **Строка 15: `<p>Статус: <span class="badge bg-secondary">Пользователь</span></p>`**:
  * Если ни одно из предыдущих условий не было истинным, отображается этот параграф.
  * `bg-secondary`: Устанавливает цвет фона бейджа во "вторичный" (обычно серый) цвет.
* **Строка 16: `{% endif %}`**: Закрывает условный оператор `if/elif/else`.
* **Строка 19: `{% endblock content %}`**: Закрывает блок `content`.

---

### 3. `static/css/main.css` (Пользовательские стили)

* **Назначение**: Хотя код не виден, этот файл, скорее всего, содержит стили для класса `.master-card`, аналогичные тем, что были в предыдущем примере (фон, скругленные углы, отступы, тень).
* **Пример содержимого (предполагаемое):**

    ```css
    .master-card {
        background-color: rgb(255, 255, 255); /* Белый фон */
        border-radius: 10px; /* Скругленные углы */
        padding: 20px; /* Внутренние отступы */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Легкая тень */
    }
    ```

---

### Как это все работает вместе

1. **Запрос пользователя**: Пользователь запрашивает URL, который сопоставлен с функцией `index` в `views.py` (например, корневой URL `/`).
2. **Обработка запроса (views.py)**:
    * Функция `index` вызывается.
    * Она создает словарь `context` с данными о пользователе, включая `user.name`, `user.age` и `user.is_stuff = True`.
    * Вызывает `render`, чтобы отобразить `first_template.html` с этими данными.
3. **Рендеринг шаблона (first_template.html)**:
    * Django начинает обрабатывать `first_template.html`.
    * Он понимает, что шаблон расширяет `base.html`, и вставляет содержимое `{% block content %}` в соответствующее место в базовом шаблоне.
    * Выводит заголовок `<h1>`.
    * Создает `div` с классом `master-card`.
    * Вставляет имя ("Сергей") и возраст (30) пользователя.
    * Доходит до условного оператора `{% if user.is_stuff %}`. Поскольку `user.is_stuff` равно `True`, выполняется код внутри этого `if` блока.
    * Отображается параграф "Статус: " с бейджем "Сотрудник", стилизованным с помощью `badge bg-warning`.
    * Блоки `elif` и `else` пропускаются.
    * Закрывается `div` и блок `content`.
4. **Применение стилей (main.css)**: Браузер получает сгенерированный HTML и применяет стили из `main.css` (и, конечно, из Bootstrap), чтобы придать карточке и бейджу соответствующий внешний вид.
5. **Отображение**: Пользователь видит страницу с заголовком, карточкой, содержащей имя и возраст "Сергея", и его статусом "Сотрудник", выделенным желтым бейджем.

Этот пример наглядно демонстрирует, как Django позволяет динамически изменять содержимое страницы на основе данных, а Bootstrap помогает легко стилизовать эти элементы, делая их адаптивными и визуально привлекательными.
