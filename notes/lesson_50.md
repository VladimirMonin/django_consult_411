## Альтернативные пути для шаблонов

### Как работает BASE_DIR

В Django для удобной работы с путями в проекте часто используется объект `BASE_DIR`. Он создается с помощью библиотеки `pathlib` и указывает на корневую директорию проекта.

```python
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
```

Здесь `Path(__file__)` — путь к текущему файлу `settings.py`, `.resolve()` преобразует его в абсолютный путь, а `.parent.parent` поднимается на два уровня вверх, чтобы получить корень проекта.

### Константа TEMPLATE_DIRS

В настройках Django в списке `TEMPLATES` есть ключ `DIRS`, который указывает, где искать шаблоны. По умолчанию Django ищет шаблоны в папках `templates` каждого приложения, если включен параметр `APP_DIRS`.

Чтобы добавить альтернативный путь для шаблонов, можно явно указать его в `DIRS`:

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],  # Альтернативный путь к шаблонам
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

### Как работает BASE_DIR / 'templates'

Выражение `BASE_DIR / 'templates'` — это использование оператора `/`, перегруженного в классе `Path` из модуля `pathlib`. Оно объединяет путь `BASE_DIR` с поддиректорией `'templates'` и возвращает новый объект пути.

Это более удобный и кроссплатформенный способ, чем `os.path.join`, так как автоматически учитывает разделители путей для текущей ОС.

### Где Django ищет шаблоны

По умолчанию, если `APP_DIRS=True`, Django ищет шаблоны в папках `templates` каждого установленного приложения.

Если указать альтернативный путь в `DIRS`, Django будет искать шаблоны и там, что позволяет хранить общие шаблоны вне приложений.

## Наследование шаблонов

![Наследование шаблонов](images/base_html.png)

### Пример наследования

В файле `first_template.html` мы можем наследовать базовый шаблон `base.html` и переопределять блоки:

```django
{% extends "base.html" %}

{% block content %}
<h1>Добро пожаловать в барбершоп "{{ name }}"!</h1>
<p>Эксперименты с типами данных</p>

<p>1 эксперимент - Число. {{integer}} </p>
<p>2 эксперимент - Число с плавающей точкой. {{float}} </p>
<p>3 эксперимент - Строка. {{string}} </p>
<p>4 эксперимент - Список чисел. {{num_list}} </p>
<p>5 эксперимент - Словарь имен. {{name_dict}} </p>
<p>6 эксперимент - Множество строк. {{string_set}} </p>
<p>7 эксперимент - Объект имени. Мастер по имени: {{name_object}} </p>
<p>8 эксперимент - Список чисел. Элемент 0: {{num_list.0}} </p>
<p>9 эксперимент - Словарь имен. Имя по ключу: {{name_dict.name}} </p>
<p>10 эксперимент - Объект имени. Мастер по атрибуту имени: {{name_object.name}} </p>
<p>11 эксперимент - Объект имени. Вызов метода age_in_days: {{name_object.age_in_days}} </p>
{% endblock content %}
```

Такой подход позволяет переиспользовать общий каркас страницы и менять только нужные части.

---

Этот конспект основан на вашем плане и обсуждении в чате, включая примеры из `settings.py` и шаблонов.

## Статика и фавикон

Сделали фавикон в ChatGPT и сжали его в онлайн конвертере в формат WebP, чтобы уменьшить размер файла.
<https://image.online-convert.com/ru/convert-to-webp>

Создали папку `static` в корне проекта в ней создали

- папку `images`
- папку `css`
- папку `js`

Поместили в папку `images` файл `favicon.webp`.

В остальных папках сделали тестовый код на проверку подключения статики.

```python
# Это константа для пути к статическим файлам (на сайте!)
STATIC_URL = 'static/'
# Это константа для пути к статическим файлам (на сервере у нас альтернативный путь)
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

```

![Загрузка статики](images/load_static.png)

Так же модификация урлов в `urls.py` для подключения статики:

- Импорты
- Добавление пути
- Что значат эти настройки

### Разница между STATIC_URL, STATICFILES_DIRS и STATIC_ROOT

В Django есть три основные настройки для работы со статическими файлами:

- **`STATIC_URL`**: Это базовый URL-адрес, по которому браузер будет запрашивать статические файлы. Например, `/static/`. Используется в шаблонах с тегом `{% static %}`.

- **`STATICFILES_DIRS`**: Список дополнительных директорий на сервере, где Django ищет статические файлы во время разработки (кроме стандартных папок `static` внутри приложений). Здесь мы указываем путь к нашей корневой папке `static`.

- **`STATIC_ROOT`**: Абсолютный путь к директории, куда будут собраны все статические файлы при выполнении команды `collectstatic` для продакшена. В режиме разработки эта настройка обычно не используется для отдачи файлов.

### Подключение статики в urls.py

Чтобы сервер разработки Django мог отдавать статические файлы из `STATICFILES_DIRS` и папок приложений, необходимо добавить соответствующий URL-паттерн в главный `urls.py` проекта. Для этого используются функции `static` и `settings`:

```python
from django.conf import settings
from django.conf.urls.static import static
# ...existing code...

urlpatterns = [
    # ...existing code...
] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

Этот код добавляет маршрут, который в режиме отладки (`DEBUG=True`) будет обрабатывать запросы к URL, начинающимся с `STATIC_URL`, и искать соответствующие файлы в директориях, указанных в `STATICFILES_DIRS` и папках `static` приложений.

### Подключение статики в шаблонах

Для использования статических файлов в шаблонах Django необходимо сначала загрузить теги статики с помощью `{% load static %}` в начале файла шаблона:

```django
{% load static %}
<!doctype html>
<html lang="ru">
  <head>
    <!-- ...existing code... -->
  </head>
  <body>
    <!-- ...existing code... -->
  </body>
</html>
```

Затем можно использовать тег `{% static 'путь/к/файлу' %}` для генерации полного URL к статическому файлу. Путь указывается относительно директорий, перечисленных в `STATICFILES_DIRS` или папок `static` приложений.

Например, для подключения CSS файла `main.css` из папки `static/css`:

```html
<link rel="stylesheet" href="{% static 'css/main.css' %}">
```

И для подключения JavaScript файла `main.js` из папки `static/js`:

```html
<script src="{% static 'js/main.js' %}"></script>
```

### Подключение изображений и фавикона

Изображения также подключаются с помощью тега `{% static %}`. Например, если у вас есть файл `logo.png` в папке `static/images`:

```html
<img src="{% static 'images/logo.png' %}" alt="Логотип">
```

Для подключения фавикона (`favicon.webp` в папке `static/images`) используется тег `<link>` в секции `<head>` шаблона:

```html
<link rel="icon" href="{% static 'images/favicon.webp' %}" type="image/webp">
```

### Структура папок для статики

В корне проекта создается папка `static`, в которой можно организовать структуру по типам файлов:

- `css/` — для таблиц стилей
- `js/` — для JavaScript файлов
- `images/` — для изображений, включая фавикон

Это позволяет удобно хранить и подключать статические ресурсы.

### Рекомендации по работе со статикой

- Всегда используйте тег `{% load static %}` в начале шаблона, чтобы подключить теги для работы со статикой.
- Используйте тег `{% static 'путь/к/файлу' %}` для генерации правильного URL к статическому файлу.
- В режиме разработки (`DEBUG=True`) Django сам обслуживает статику из папок, указанных в `STATICFILES_DIRS` и папок `static` приложений.
- В продакшене используйте команду `collectstatic`, чтобы собрать все статические файлы в папку `STATIC_ROOT`, откуда их будет обслуживать веб-сервер.

## Переменные окружения 

poetry add python-dotenv
.env
.env.example


## Конвертеры путей в Django

Все пути нашего сайта в Django распологаются в `urls.py`. И сейчас у нас это выглядит так:

```python
urlpatterns = [
    path("admin/", admin.site.urls),
    path("", index),
] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

Мы можем добавить пути формата `thanks` или `about` или же `masters` для отображения разной информации.
Но что если нам надо будет вывести информацию о мастере по его имени или id?

Допустим возьмем `id`. Как нам из маршрута получить id мастера и вывести его информацию?

Для этого мы можем использовать конвертеры путей в Django. Конвертеры позволяют извлекать переменные из URL и передавать их в представление.

```python
urlpatterns = [
    path("masters/<int:master_id>/", master_detail, name="master_detail"),
]
```

Для такого маршрута потребуется специальная функция представления `master_detail`, которая будет принимать параметр `id` и обрабатывать запрос:

```python
def master_detail(request, master_id):
    # Здесь можно получить информацию о мастере по его id
    master = ...
    return render(request, "master_detail.html", {"master": master})
```

Когда пользователь перейдет по URL, например, `/masters/1/`, Django вызовет функцию `master_detail` и передаст ей значения:

```python
# kwargs будет содержать {'request': request, 'master_id': 1}
master_detail(**kwargs)
```
