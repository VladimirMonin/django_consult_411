## Альтернативные пути для шаблонов

### Как работает BASE_DIR

В Django для удобной работы с путями в проекте часто используется объект `BASE_DIR`. Он создается с помощью библиотеки `pathlib` и указывает на корневую директорию проекта.

```python
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
```

Здесь `Path(__file__)` — путь к текущему файлу `settings.py`, `.resolve()` преобразует его в абсолютный путь, а `.parent.parent` поднимается на два уровня вверх, чтобы получить корень проекта.

### Константа TEMPLATE_DIRS

В настройках Django в списке `TEMPLATES` есть ключ `DIRS`, который указывает, где искать шаблоны. По умолчанию Django ищет шаблоны в папках `templates` каждого приложения, если включен параметр `APP_DIRS`.

Чтобы добавить альтернативный путь для шаблонов, можно явно указать его в `DIRS`:

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],  # Альтернативный путь к шаблонам
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

### Как работает BASE_DIR / 'templates'

Выражение `BASE_DIR / 'templates'` — это использование оператора `/`, перегруженного в классе `Path` из модуля `pathlib`. Оно объединяет путь `BASE_DIR` с поддиректорией `'templates'` и возвращает новый объект пути.

Это более удобный и кроссплатформенный способ, чем `os.path.join`, так как автоматически учитывает разделители путей для текущей ОС.

### Где Django ищет шаблоны

По умолчанию, если `APP_DIRS=True`, Django ищет шаблоны в папках `templates` каждого установленного приложения.

Если указать альтернативный путь в `DIRS`, Django будет искать шаблоны и там, что позволяет хранить общие шаблоны вне приложений.

## Наследование шаблонов

![Наследование шаблонов](images/base_html.png)

### Пример наследования

В файле `first_template.html` мы можем наследовать базовый шаблон `base.html` и переопределять блоки:

```django
{% extends "base.html" %}

{% block content %}
<h1>Добро пожаловать в барбершоп "{{ name }}"!</h1>
<p>Эксперименты с типами данных</p>

<p>1 эксперимент - Число. {{integer}} </p>
<p>2 эксперимент - Число с плавающей точкой. {{float}} </p>
<p>3 эксперимент - Строка. {{string}} </p>
<p>4 эксперимент - Список чисел. {{num_list}} </p>
<p>5 эксперимент - Словарь имен. {{name_dict}} </p>
<p>6 эксперимент - Множество строк. {{string_set}} </p>
<p>7 эксперимент - Объект имени. Мастер по имени: {{name_object}} </p>
<p>8 эксперимент - Список чисел. Элемент 0: {{num_list.0}} </p>
<p>9 эксперимент - Словарь имен. Имя по ключу: {{name_dict.name}} </p>
<p>10 эксперимент - Объект имени. Мастер по атрибуту имени: {{name_object.name}} </p>
<p>11 эксперимент - Объект имени. Вызов метода age_in_days: {{name_object.age_in_days}} </p>
{% endblock content %}
```

Такой подход позволяет переиспользовать общий каркас страницы и менять только нужные части.

---

Этот конспект основан на вашем плане и обсуждении в чате, включая примеры из `settings.py` и шаблонов.