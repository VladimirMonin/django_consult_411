# Lesson 53

## Псевдонимы маршрутов и заблонный тег URL

### Псевдонимы маршрутов и шаблонный тег `url`

В Django для создания URL-адресов, которые не зависят от жестко закодированных путей, используются псевдонимы маршрутов (или "именованные URL") и шаблонный тег `{% url %}`. Это обеспечивает гибкость и упрощает поддержку проекта, так как при изменении URL-паттерна вам не придется обновлять его во всех местах, где он используется.

Рассмотрим пример из нашего проекта:

```python
# barbershop/urls.py
from django.urls import path
from core.views import OrderListView

urlpatterns = [
    path("orders/", OrderListView.as_view(), name="order_list"),
]
```

Здесь мы определили маршрут для списка заявок с именем `order_list`.

#### Использование псевдонимов маршрутов в Python коде

В Python коде, например, во `views.py` или `models.py`, для получения URL по его имени используется функция `reverse()` из `django.urls`.

```python
from django.urls import reverse

# name = "order_list" - это псевдоним (имя) маршрута, определенный в urls.py
url = reverse("order_list")
# Результат: url будет содержать "/orders/" (или другой путь, если он изменится в urls.py)
```
**Пояснение:** Функция `reverse()` принимает имя маршрута (`"order_list"`) и возвращает соответствующий URL-путь. Это позволяет избежать жесткого кодирования URL-адресов в коде Python, делая его более гибким и менее подверженным ошибкам при изменении структуры URL.

#### Использование шаблонного тега `url` в HTML-шаблонах

В HTML-шаблонах Django для получения URL по его имени используется шаблонный тег `{% url %}`.

```html
<a href="{% url 'order_list' %}">Список заявок</a>
```
**Пояснение:** Тег `{% url %}` работает аналогично функции `reverse()` в Python, но используется непосредственно в шаблонах. Он генерирует правильный URL-адрес на основе имени маршрута (`'order_list'`) во время рендеринга шаблона.

#### Почему не следует использовать жестко закодированные пути

```html
<a href="/orders/">Список заявок</a>
```
**Пояснение:** Использование жестко закодированных путей, таких как `/orders/`, является плохой практикой. Если URL-паттерн для списка заявок изменится в `urls.py` (например, на `/admin/orders/`), вам придется вручную обновлять все такие ссылки в ваших HTML-шаблонах. Это может привести к ошибкам 404 и усложняет поддержку проекта. Использование `{% url %}` автоматически адаптируется к изменениям в `urls.py`.


## Наш вариант
Мы остановились на 

def get_main_menu():
    """Функция возвращает список пунктов меню для сайта"""
    return [
        {"name": "Главная", "url": reverse("landing")},
        {"name": "О нас", "url": reverse("landing") + "#about"},
        {"name": "Преимущества", "url": reverse("landing") + "#benefits"},
        {"name": "Мастера", "url": reverse("landing") + "#masters"},
        {"name": "Услуги", "url": reverse("landing") + "#services"},
        {"name": "Запись", "url": reverse("landing") + "#booking"},
        {"name": "Управление", "url": reverse("order_list")},
    ]


Потому что мы не можем использовать в шаблонах тег URL с якорными ссылками.

### Почему нельзя использовать тег `url` с якорными ссылками

Тег `{% url %}` в Django предназначен для генерации URL-адресов на основе имен маршрутов, определенных в файлах `urls.py`. Он работает на стороне сервера, сопоставляя имя маршрута с соответствующим URL-паттерном и генерируя полный путь.

Якорные ссылки (или фрагменты URL, начинающиеся с `#`) являются частью URL, но они обрабатываются исключительно браузером на стороне клиента. Сервер не видит и не обрабатывает часть URL после `#`. Поэтому тег `{% url %}` не имеет встроенной функциональности для добавления якорных ссылок.

Если вам нужно добавить якорную ссылку к URL, сгенерированному с помощью `reverse` (в Python коде) или `{% url %}` (в шаблоне), вы должны добавить ее вручную, как показано в нашем проекте:

```python
# В Python коде
{"name": "О нас", "url": reverse("landing") + "#about"},
```

```html
{# В шаблоне, если бы это было возможно напрямую, но это не так для {% url %} #}
{# <a href="{% url 'landing' %}#about">О нас</a> #}
{# Вместо этого, если бы мы передавали URL без якоря, а якорь добавляли бы JS, то это было бы возможно. #}
```

В нашем случае, функция `get_main_menu` формирует URL-адреса, объединяя результат `reverse()` с якорной ссылкой, что является корректным подходом.

## Контекстный процессор

### Что такое контекстные процессоры?
Контекстные процессоры в Django — это функции, которые принимают объект `request` в качестве аргумента и возвращают словарь, который будет добавлен в контекст каждого шаблона, отрисовываемого с использованием `RequestContext`. Это означает, что данные, возвращаемые контекстным процессором, становятся доступными во всех шаблонах вашего проекта без необходимости явно передавать их в каждом `render()` или `render_to_response()`.

Они очень полезны для добавления глобальных данных, таких как информация о текущем пользователе, настройки сайта, пункты меню или отладочная информация, которые должны быть доступны на каждой странице.

### Где они подключаются?
Контекстные процессоры подключаются в файле `settings.py` вашего проекта, в секции `TEMPLATES['OPTIONS']['context_processors']`. Это список строк, каждая из которых является путем к функции контекстного процессора.

Пример из `barbershop/settings.py`:
```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'core.context_processors.get_main_menu', # Наш кастомный процессор
            ],
        },
    },
]
```

### Какие там уже есть и за что отвечают?
По умолчанию Django включает несколько полезных контекстных процессоров:

*   `django.template.context_processors.debug`: Добавляет отладочную информацию в контекст, если `DEBUG` установлен в `True`. Включает переменные `debug` и `sql_queries`.
*   `django.template.context_processors.request`: Добавляет объект `HttpRequest` (`request`) в контекст шаблона. Это позволяет вам получать доступ к информации о текущем запросе (например, `request.user`, `request.path`, `request.GET`).
*   `django.contrib.auth.context_processors.auth`: Добавляет информацию об аутентифицированном пользователе (`user`) и разрешениях (`perms`) в контекст. Это позволяет проверять, вошел ли пользователь в систему, и имеет ли он определенные разрешения.
*   `django.contrib.messages.context_processors.messages`: Добавляет сообщения из фреймворка сообщений Django (`messages`) в контекст шаблона. Это позволяет отображать одноразовые уведомления пользователю (например, "Ваш профиль успешно обновлен").
*   `django.template.context_processors.i18n`: Добавляет переменные, связанные с интернационализацией.
*   `django.template.context_processors.media`: Добавляет URL для медиа-файлов (`MEDIA_URL`).
*   `django.template.context_processors.static`: Добавляет URL для статических файлов (`STATIC_URL`).
*   `django.template.context_processors.tz`: Добавляет информацию о текущем часовом поясе.

В нашем проекте мы добавили:
*   `core.context_processors.get_main_menu`: Этот процессор добавляет список пунктов главного меню в контекст шаблона под ключом `"menu"`. Это позволяет нам отрисовывать меню в `base.html` (или любом другом шаблоне) без необходимости передавать его из каждого представления.

```python
# core/context_processors.py
from django.urls import reverse

def get_main_menu(request):
    """Функция возвращает список пунктов меню для сайта"""
    context = {
        "menu": [
            {"name": "Главная", "url": reverse("landing")},
            {"name": "О нас", "url": reverse("landing") + "#about"},
            {"name": "Преимущества", "url": reverse("landing") + "#benefits"},
            {"name": "Мастера", "url": reverse("landing") + "#masters"},
            {"name": "Услуги", "url": reverse("landing") + "#services"},
            {"name": "Запись", "url": reverse("landing") + "#booking"},
            {"name": "Управление", "url": reverse("order_list")},
        ]
    }
    return context
```




## Убрать меню из шаблона

Теперь когда у нас контекстный процессор а меню подключено в базовый шаблон оно будет на ВСЕХ страницах сайта.
И его конечно же захочется выключить где-то.

Можно просто сделать в базовом шаблоне
    {% block header %}
    <header>
        {% include "nav_menu_include.html" %}
    </header>
    {% endblock header %}



А в шаблоне где надо выключить
{% comment %} 
Так можно выключить блок из базового шаблона и убрать меню
{% block header %}
{% endblock header %} 

{% endcomment %}


## BS5 классы для того чтобы сместить футер вниз

Для того чтобы футер всегда оставался внизу страницы, даже если контента на странице мало, используются следующие классы Bootstrap 5:

```html
  <body class="d-flex flex-column min-vh-100">
    <main class="flex-grow-1">
    <footer class="container mt-5 py-4 text-center border-top">
```

### Пояснения по каждому из классов и как это будет работать

*   `d-flex`: Этот класс делает элемент (в данном случае `<body>`) флекс-контейнером. Флексбокс — это одномерный макетный метод, который позволяет легко выравнивать и распределять пространство между элементами в контейнере.
*   `flex-column`: Этот класс устанавливает направление флекс-элементов внутри `<body>` по вертикали, то есть они будут располагаться друг под другом. Это важно, так как мы хотим, чтобы `header`, `main` и `footer` располагались вертикально.
*   `min-vh-100`: Этот класс устанавливает минимальную высоту элемента `<body>` равной 100% от высоты видового экрана (viewport height). Это гарантирует, что `<body>` всегда будет занимать всю доступную высоту окна браузера, даже если его содержимое невелико.
*   `<main class="flex-grow-1">`:
    *   `flex-grow-1`: Этот класс применяется к элементу `<main>`. Он указывает, что этот элемент должен "расти" и занимать все доступное пространство внутри своего флекс-контейнера (`<body>`). Таким образом, если контента на странице мало, `<main>` растянется, толкая `<footer>` вниз. Если контента много, `<main>` будет занимать столько места, сколько нужно, а `<footer>` будет следовать за ним.
*   `<footer class="container mt-5 py-4 text-center border-top">`:
    *   `container`: Стандартный класс Bootstrap для создания адаптивного контейнера фиксированной ширины.
    *   `mt-5`: Устанавливает верхний отступ (margin-top) равным 3rem (по умолчанию в Bootstrap 5). Это создает пространство между основным контентом и футером.
    *   `py-4`: Устанавливает вертикальный внутренний отступ (padding-top и padding-bottom) равным 1.5rem.
    *   `text-center`: Выравнивает текст внутри футера по центру.
    *   `border-top`: Добавляет верхнюю границу к футеру, визуально отделяя его от основного контента.

Вместе эти классы создают "липкий" футер, который всегда находится внизу страницы:
1.  `<body>` становится флекс-контейнером, занимающим всю высоту экрана.
2.  Элементы внутри `<body>` (например, `header`, `main`, `footer`) располагаются вертикально.
3.  Элемент `<main>` "растет", заполняя любое свободное пространство, что гарантирует, что `<footer>` всегда будет прижат к нижней части `<body>`, а значит, и к нижней части видового экрана.
